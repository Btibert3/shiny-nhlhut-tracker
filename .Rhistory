rm(URL)
con <- neo4j_api$new(url = "http://localhost:7474",
user = "neo4j",
password = "password")
con$ping()
shiny::runApp('hut-price-tracker')
## global options
options(stringsAsFactors = FALSE)
library(neo4r)
library(optparse)
con <- neo4j_api$new(url = "http://localhost:7474",
user = "neo4j",
password = "password")
con$ping()
library(stringr)
parser <- OptionParser()
parser <- add_option(parser, c("--initneo"),
action = "store_true",
default = FALSE,
help = str_trim("This will delete all data, and ensure proper
indexes are setup."))
argv = parse_args(parser)
argv
## if initneo, wipe the data and ensure indexes in place
INITNEO = argv$initneo
INITNEO =  TRUE
# Wipe the data
CQL = "MATCH (n) DETACH DELETE n;"
call_api(CQL,  con)
call_api(CQL,  con, output = "json", include_stats = TRUE)
call_api(CQL,  con, output = "json", include_stats = TRUE)
call_api(CQL,  con, output = "json", include_stats = TRUE)
call_api(CQL,  con, output = "json", include_stats = TRUE, meta = TRUE)
call_api(CQL,  con, output = "json", include_stats = TRUE, meta = TRUE)
call_api(CQL,  con)
## global options
options(stringsAsFactors = FALSE)
## load the libraries
library(neo4r)
library(optparse)
library(stringr)
library(jsonlite)
library(dplyr)
library(tidyr)
library(stringr)
## connect to the running neo4j database that is running locally in docker
con <- neo4j_api$new(url = "http://localhost:7474",
user = "neo4j",
password = "password")
## ensure that the connection to the datastore is active
if (con$ping() !=200 ) {
stop("unable to connect to the neo4j backend")
}
# get the constraints from the database
constraints = con$get_constraints()
constraints
hutdb = readRDS("data/hut.rds")
glimpse(hutdb)
## ensure that the constraints are listed by name, if not add them
call_api("CREATE CONSTRAINT ON (n:Card) ASSERT n.id IS UNIQUE;", con)
## ensure that the constraints are listed by name, if not add them
call_api("CREATE CONSTRAINT ON (n:Card) ASSERT n.id IS UNIQUE;", con)
## get the constraints from the database
constraints = con$get_constraints()
constraints
## ensure that the constraints are listed by name, if not add them
call_api("CREATE CONSTRAINT ON (n:Card) ASSERT n.id IS UNIQUE;", con)
## the url
URL = "https://hutdb.net/ajax/stats.php?year=19&page=%s&selected=OVR&sort=DESC"
i = 100
URL2 = sprintf(URL, i)
results = fromJSON(URL2)
players = results %>% filter(!is.na(Player)) %>% select(-results)
colnames(players) = tolower(colnames(players))
players = players %>% mutate_at(vars(year, wgt:salary, age:jersey), funs(as.numeric))
glimpse(players)
players = players %>% select(id, ovr, card, team, player, position, shoots, type)
CQL = "
MERGE (n:Card {id:row.id})
ON.CREATE SET n.ovr = INT(row.ovr),
n.card = row.card,
n.team = row.team,
n.player = row.player
n.position = row.position,
n.shoots = row.shoots,
n.type = row.type
RETURN n
"
player = players[1,]
CQL = "
MERGE (n:Card {id:%s)
ON.CREATE SET n.ovr = INT(%s),
n.card = %s,
n.team = %s,
n.player = %s
n.position = %s,
n.shoots = %s,
n.type = %s
RETURN n
"
CQL = sprintf(CQL, player$id,
player$ovr,
player$card,
player$team,
player$position,
player$shoots,
player$type)
CQL = "
MERGE (n:Card {id:%s)
ON.CREATE SET n.ovr = INT(%s),
n.card = %s,
n.team = %s,
n.player = %s
n.position = %s,
n.shoots = %s,
n.type = %s
RETURN n
"
CQL = sprintf(CQL, player$id,
player$ovr,
player$card,
player$team,
player$player,
player$position,
player$shoots,
player$type)
CQL
cat(CQL)
call_api(CQL, con)
for (player in players) {
CQL = "
MERGE (n:Card {id:'%s')
ON.CREATE SET n.ovr = INT(%s),
n.card = '%s',
n.team = '%s',
n.player = '%s'
n.position = '%s',
n.shoots = '%s',
n.type = '%s'
RETURN n
"
CQL = sprintf(CQL, player$id,
player$ovr,
player$card,
player$team,
player$player,
player$position,
player$shoots,
player$type)
call_api(CQL, con)
call_api(CQL, con)
CQL = "
MERGE (n:Card {id:'%s')
ON.CREATE SET n.ovr = INT('%s'),
n.card = '%s',
n.team = '%s',
n.player = '%s'
n.position = '%s',
n.shoots = '%s',
n.type = '%s'
RETURN n
"
CQL = sprintf(CQL, player$id,
player$ovr,
player$card,
player$team,
player$player,
player$position,
player$shoots,
player$type)
call_api(CQL, con)
CQL = "
MERGE (n:Card {id:'%s')
ON.CREATE SET n.ovr = '%s',
n.card = '%s',
n.team = '%s',
n.player = '%s'
n.position = '%s',
n.shoots = '%s',
n.type = '%s'
RETURN n
"
CQL = sprintf(CQL, player$id,
player$ovr,
player$card,
player$team,
player$player,
player$position,
player$shoots,
player$type)
call_api(CQL, con)
CQL = "
MERGE (n:Card {id:'%s'})
ON.CREATE SET n.ovr = '%s',
n.card = '%s',
n.team = '%s',
n.player = '%s'
n.position = '%s',
n.shoots = '%s',
n.type = '%s'
RETURN n
"
CQL = sprintf(CQL, player$id,
player$ovr,
player$card,
player$team,
player$player,
player$position,
player$shoots,
player$type)
call_api(CQL, con)
CQL = "
MERGE (n:Card {id:'%s'})
ON CREATE SET n.ovr = '%s',
n.card = '%s',
n.team = '%s',
n.player = '%s'
n.position = '%s',
n.shoots = '%s',
n.type = '%s'
RETURN n
"
CQL = sprintf(CQL, player$id,
player$ovr,
player$card,
player$team,
player$player,
player$position,
player$shoots,
player$type)
call_api(CQL, con)
CQL = "
MERGE (n:Card {id:'%s'})
ON CREATE SET n.ovr = '%s',
n.card = '%s'
RETURN n
"
CQL = sprintf(CQL, player$id,
player$ovr,
player$card,
player$team,
player$player,
player$position,
player$shoots,
player$type)
call_api(CQL, con)
CQL = "
MERGE (n:Card {id:'%s'})
ON CREATE SET n.ovr = '%s',
n.card = '%s',
n.team = '%s',
n.player = '%s'
RETURN n
"
CQL = sprintf(CQL, player$id,
player$ovr,
player$card,
player$team,
player$player,
player$position,
player$shoots,
player$type)
call_api(CQL, con)
CQL = "
MERGE (n:Card {id:'%s'})
ON CREATE SET n.ovr = '%s',
n.card = '%s',
n.team = '%s',
n.player = '%s',
n.position = '%s',
n.shoots = '%s',
n.type = '%s'
RETURN n
"
CQL = sprintf(CQL, player$id,
player$ovr,
player$card,
player$team,
player$player,
player$position,
player$shoots,
player$type)
call_api(CQL, con)
call_api(CQL, con)
call_api(CQL, con)
SEEDNEO = argv$seedneo
if (SEEDNEO) {
## ensure that the constraints are listed by name, if not add them
## will not fail if already there, which is nice
call_api("CREATE CONSTRAINT ON (n:Card) ASSERT n.id IS UNIQUE;", con)
## the url
URL = "https://hutdb.net/ajax/stats.php?year=19&page=%s&selected=OVR&sort=DESC"
## check the sequence number of N = 5800 below, NEW CARDS ADDED so need to raise
for (i in seq(0, 5900, 100)) {
URL2 = sprintf(URL, i)
results = fromJSON(URL2)
players = results %>% filter(!is.na(Player)) %>% select(-results)
colnames(players) = tolower(colnames(players))
players = players %>% mutate_at(vars(year, wgt:salary, age:jersey), funs(as.numeric))
players = players %>% select(id, ovr, card, team, player, position, shoots, type)
for (player in players) {
CQL = "
MERGE (n:Card {id:'%s'})
ON CREATE SET n.ovr = '%s',
n.card = '%s',
n.team = '%s',
n.player = '%s',
n.position = '%s',
n.shoots = '%s',
n.type = '%s'
RETURN n
"
CQL = sprintf(CQL, player$id,
player$ovr,
player$card,
player$team,
player$player,
player$position,
player$shoots,
player$type)
call_api(CQL, con)
}
rm(URL2, results, players, CQL)
message("finished ", i, "\n")
}
}
## load the packages
library(neo4r)
library(neo4r)
library(stringr)
library(jsonlite)
library(dplyr)
library(tidyr)
library(stringr)
## ensure that the constraints are there
call_api("CREATE CONSTRAINT ON (n:Card) ASSERT n.id IS UNIQUE;", con)
## ensure that the constraints are there
call_api("CREATE CONSTRAINT ON (n:Card) ASSERT n.id IS UNIQUE;", con, output="r")
source('~/github/shiny-nhlhut-tracker/import-data.R', echo=TRUE)
source('~/github/shiny-nhlhut-tracker/import-data.R', echo=TRUE)
## the url
URL = "https://hutdb.net/ajax/stats.php?year=19&page=%s&selected=OVR&sort=DESC"
i = 0
URL2 = sprintf(URL, i)
results = fromJSON(URL2)
players = results %>% filter(!is.na(Player)) %>% select(-results)
## check the sequence number of N = 5800 below, NEW CARDS ADDED so need to raise
for (i in seq(0, 5900, 100)) {
## the url
URL = "https://hutdb.net/ajax/stats.php?year=19&page=%s&selected=OVR&sort=DESC"
URL2 = sprintf(URL, i)
results = fromJSON(URL2)
players = results %>% filter(!is.na(Player)) %>% select(-results)
colnames(players) = tolower(colnames(players))
players = players %>% mutate_at(vars(year, wgt:salary, age:jersey), funs(as.numeric))
players = players %>% select(id, ovr, card, team, player, position, shoots, type)
for (player in players) {
CQL = "
MERGE (n:Card {id:'%s'})
ON CREATE SET n.ovr = '%s',
n.card = '%s',
n.team = '%s',
n.player = '%s',
n.position = '%s',
n.shoots = '%s',
n.type = '%s'
RETURN n
"
CQL = sprintf(CQL, player$id,
player$ovr,
player$card,
player$team,
player$player,
player$position,
player$shoots,
player$type)
call_api(CQL, con)
}
rm(URL2, results, players, CQL)
message("finished ", i, "\n")
}
## the url
URL = "https://hutdb.net/ajax/stats.php?year=19&page=%s&selected=OVR&sort=DESC"
URL2 = sprintf(URL, i)
results = fromJSON(URL2)
players = results %>% filter(!is.na(Player)) %>% select(-results)
colnames(players) = tolower(colnames(players))
players = players %>% mutate_at(vars(year, wgt:salary, age:jersey), funs(as.numeric))
players = players %>% select(id, ovr, card, team, player, position, shoots, type)
p = 1
source('~/github/shiny-nhlhut-tracker/import-data.R', echo=TRUE)
suppressPackageStartupMessages(library(dplyr))
glimpse(hutdb)
cards = players %>% arrange(desc(create_date))
cards = hutdb %>% arrange(desc(create_date))
head(cards)
x = call_api("MATCH (c:Card) RETURN c", con, type="rows", output="r")
x = call_api("MATCH (c:Card) RETURN c", con, type="row", output="r")
names(x)
hutdb = x$c
hutdb
p
players
## the url
URL = "https://hutdb.net/ajax/stats.php?year=19&page=%s&selected=OVR&sort=DESC"
URL2 = sprintf(URL, i)
results = fromJSON(URL2)
players = results %>% filter(!is.na(Player)) %>% select(-results)
colnames(players) = tolower(colnames(players))
players = players %>% mutate_at(vars(year, wgt:salary, age:jersey), funs(as.numeric))
players = players %>% select(id, ovr, card, team, player, position, shoots, type)
player = players[p, ]
CQL = "
MERGE (n:Card {id:'%s'})
ON CREATE SET n.ovr = '%s',
n.card = '%s',
n.team = '%s',
n.player = '%s',
n.position = '%s',
n.shoots = '%s',
n.type = '%s'
WITH n SET n.playerid = n.ovr+'-'+n.card+'-'+n.player
RETURN n
player = players[p, ]
CQL = sprintf(CQL, player$id,
player$ovr,
player$card,
player$team,
player$player,
player$position,
player$shoots,
player$type)
call_api(CQL, con)
CQL = "
MERGE (n:Card {id:'%s'})
ON CREATE SET n.ovr = '%s',
n.card = '%s',
n.team = '%s',
n.player = '%s',
n.position = '%s',
n.shoots = '%s',
n.type = '%s'
WITH n SET n.playerid = n.ovr+'-'+n.card+'-'+n.player
RETURN n
"
player = players[p, ]
CQL = sprintf(CQL, player$id,
player$ovr,
player$card,
player$team,
player$player,
player$position,
player$shoots,
player$type)
call_api(CQL, con)
player
CQL = "MATCH (c:Card) RETURN c"
x = call_api("MATCH (c:Card) RETURN c", con, type="row", output="r")
hutdb = x$c
glimpse(hutdb)
## load the data every time the server loads
# hutdb = readRDS("../data/hut.rds")
x = call_api("MATCH (n:Card) RETURN n ", con, type="row", output="r")
hutdb = x$c
head(hutdb)
hutdb = x$c
head(hutdb)
hutdb = x$c
hutdb = x$n
glimpse(hutdb)
shiny::runApp('hut-price-tracker')
runApp('hut-price-tracker')
runApp('hut-price-tracker')
runApp('hut-price-tracker')
runApp('hut-price-tracker')
## bring the data back (yes, ineffecient) and save to data/hutdb.rds
x = call_api("MATCH (n:Card) RETURN n", con, type="row", output="r")
hutdb = x$n
saveRDS(hutdb, "data/hut.rds")
parser <- add_option(parser, c("--genlist"),
action = "store_true",
default = FALSE,
help = str_trim("Query all of the Cards and generate the input list for faster access in the user layer."))
argv = parse_args(parser)
parser <- OptionParser()
parser <- add_option(parser, c("--initneo"),
action = "store_true",
default = FALSE,
help = str_trim("This will delete all data, and ensure proper
indexes are setup."))
parser <- add_option(parser, c("--seedneo"),
action = "store_true",
default = FALSE,
help = str_trim("This will collect a new dataset and
add any new cards to the database."))
parser <- add_option(parser, c("--genlist"),
action = "store_true",
default = FALSE,
help = str_trim("Query all of the Cards and generate the input list for faster access in the user layer."))
argv = parse_args(parser)
runApp('hut-price-tracker')
setwd("~/Downloads/")
library(xaringan)
detach("package:xaringan", unload = TRUE)
Sys.info()
sessionInfo()
sessionInfo()
library(xaringan)
sessionInfo()
setwd("~/github/shiny-nhlhut-tracker")
setwd("~/github/shiny-nhlhut-tracker")
shiny::runApp('hut-price-tracker')
